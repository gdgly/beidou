客户端程序模拟北斗接收主机，与服务端通过socket通信。

程序包括7个源文件 Init.c; Socket_recieve.c; BD_recieve.c; BD_write.c; BD_split.c; BD_combine.c; Serial_port.c

为了方便调试，程序中将子包长度定义成了5。实际运行过程中，需要修改成北斗报文长度。
修改位置在BD_recieve.c 的头部 
#define  SP_LEN 5

shell执行make命令即可编译

shell执行sudo ./main开始运行

配置文件为Config.txt。
第一行 服务端IP地址
第二行 服务端socket端口号
第三行 自己的北斗接收机16进制地址（字母A～E需大写！）
第四行 北斗接收机占用的串口文件
第五行 串口波特率
第六行 串口其他设置（81n表示8为数据位，1位停止位，无奇偶校验）
注意！为避免错误，配置文件以回车符结尾。




可能存在的bug：
程序结构采用的是多线程共享全局变量同步的方式，应该不会出现死锁问题，有极低可能有不同步问题。（未论证是否一定有不同步问题，就算有，概率也极低极低，重启即可）

shell终端显示数据时可能会出现一段数据中夹杂着另外一段程序的数据。这种现象不一定是bug，有可能是多个线程抢占shell终端造成的。


每次数据未收完整保存的临时文件均未删除。


服务端发送过来的命令，客户端封装成北斗报文后发送。程序并不支持可靠通信，即目的北斗端接收数据即可，不用回ACK，最好是一定不要回ACK，可能会造成bug。

北斗两端可靠通信的数据格式是：
发送报文：hour min 子包号 子包总数 数据
ACK：    hour min 缺少子包数 缺少的子包
每个字段占一个字节。

当发送报文中子包号为0的时候，相当于ASK请求，这时接收端开始查询是否缺少子包，并发送ACK。然后发送端根据ACK来确定是否需要重新补发子包，并再次发送ASK。

这个过程中存在一个问题：接收端在收到ASK后才进行查找并进行下一步动作。如果发送端发送子包有n个，即最少需要发送n+1个报文。
当n不为1时，影响不大。当n为1时，就需要发送2个报文。效率只有50%.

最简单的解决办法：当接收端收到子包总数为1的数据时，立马回复ACK。
这样也会存在一个潜在的bug。在全双工的情况下会出现。
如果收到的报文为： hour min 1 1 XXXX
无法判断这个报文到底是 子包总数为1，子包号为1的发送报文 还是 缺少1个子包，缺少子包号为1的ACK报文。
但是在本程序中不存在这种情况，因为到目前为止，本程序不能算严格意义上的全双工。之后程序如果需要拓展成全双工，就会有问题。

完美的解决方案是：在报头中加1个bit用来表示是否需要回复ACK即可。




测试用数据：
24 54 58 58 58 00 1E 02 00 A5 60 04 E3 C8 00 00 00 50 A4 ff ff 00 03 32 32 32 32 32 ff ff
24 54 58 58 58 00 1E 02 00 A5 60 04 E3 C8 00 00 00 50 A4 ff ff 01 03 31 32 33 34 35 ff ff
24 54 58 58 58 00 1E 02 00 A5 60 04 E3 C8 00 00 00 50 A4 ff ff 02 03 35 34 33 32 31 ff ff
24 54 58 58 58 00 1E 02 00 A5 60 04 E3 C8 00 00 00 50 A4 ff ff 03 03 33 33 33 33 33 ff ff
